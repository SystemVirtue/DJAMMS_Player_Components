console.log('[main] main.js loaded, starting ObieElectronPlayer');

const { app, BrowserWindow, screen, ipcMain } = require('electron');
console.log('[main] electron required');
const log = require('electron-log');
console.log('[main] electron-log required');
const QueueOrchestrator = require('../integration/queue-orchestrator');
console.log('[main] QueueOrchestrator required');
const LocalFileManager = require('../integration/local-file-manager');
console.log('[main] LocalFileManager required');
const SupabaseAdapter = require('../integration/supabase-adapter');
console.log('[main] SupabaseAdapter required');
const PreferencesManager = require('./preferences-manager');
console.log('[main] PreferencesManager required');
const CommandProcessor = require('../integration/command-processor');
console.log('[main] CommandProcessor required');
const SetupWizard = require('./setup-wizard');
console.log('[main] SetupWizard required');
const path = require('path');
console.log('[main] path required');

// ============================================================================
// DEVELOPMENT CRASH HANDLERS - Prevent hanging on fatal errors
// ============================================================================

const isDev = process.env.NODE_ENV !== 'production' || process.argv.includes('--debug');

if (isDev) {
  process.on('uncaughtException', (error) => {
    console.error('[FATAL] Main Process Uncaught Exception:');
    console.error(error);
    console.error(error.stack);
    process.exit(1);
  });

  process.on('unhandledRejection', (reason, promise) => {
    console.error('[FATAL] Main Process Unhandled Rejection:');
    console.error('Promise:', promise);
    console.error('Reason:', reason);
    console.error(reason?.stack);
    process.exit(1);
  });

  console.log('[main] Development crash handlers enabled');
}

class ObieElectronPlayer {
  constructor() {
    console.log('[main] ObieElectronPlayer constructor called');
    this.mainWindow = null;
    this.orchestrator = null;
    this.supabase = null;
    this.commandProcessor = null;
    this.isShuttingDown = false;
    this.preferences = new PreferencesManager();
    console.log('[main] ObieElectronPlayer constructor finished');
  }

    async onAppReady() {
      // Load preferences first
      const prefs = await this.preferences.load();
      console.log('[main] Loaded preferences:', Object.keys(prefs));

      // Don't recreate orchestrator if it already exists
      if (this.orchestrator) {
        console.log('[main] Orchestrator already exists, skipping recreation');
        // Send orchestrator-ready to renderer
        this.mainWindow.webContents.send('orchestrator-ready');
        // Set up event listeners for existing orchestrator
        this.setupOrchestratorEventListeners();
        return;
      }
      const playlistsRoot = prefs.djammsPath || prefs.playlistsPath || process.env.DJAMMS_PROJECT_FOLDER_PATH;
      console.log('[main] playlistsRoot:', playlistsRoot);
      const fileManager = new LocalFileManager(playlistsRoot);
      console.log('[main] LocalFileManager created');
      
      // Initialize Supabase adapter
      this.supabase = new SupabaseAdapter();
      const playerId = process.env.PLAYER_ID || 'electron-player-1';
      
      this.orchestrator = new QueueOrchestrator(this.supabase, fileManager);
      console.log('[main] QueueOrchestrator created');
      await this.orchestrator.initialize();
      console.log('[main] QueueOrchestrator initialized');

      // Initialize CommandProcessor
      this.commandProcessor = new CommandProcessor(this.orchestrator, this.supabase);
      await this.commandProcessor.initialize();
      console.log('[main] CommandProcessor initialized');

      // Send orchestrator-ready to renderer
      this.mainWindow.webContents.send('orchestrator-ready');

      // Set up orchestrator event listeners
      this.setupOrchestratorEventListeners();

      // load default playlist path from env
      const defaultPlaylistPath = process.env.DJAMMS_DEFAULT_PLAYLIST_PATH || (playlistsRoot ? `${playlistsRoot}/DJAMMS Default` : null);
      if (defaultPlaylistPath) {
        const playlist = await fileManager.getPlaylistByPath(defaultPlaylistPath);
        if (playlist && playlist.videos && playlist.videos.length > 0) {
          // Sync videos to Supabase if connected
          if (this.supabase.connected()) {
            try {
              await this.supabase.syncLocalVideos(playerId, playlist.videos);
              console.log(`[main] Synced ${playlist.videos.length} videos to Supabase`);
            } catch (syncError) {
              console.warn('[main] Failed to sync videos to Supabase:', syncError.message);
            }
          }

          // Shuffle the playlist randomly before adding to queue
          function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
              const j = Math.floor(Math.random() * (i + 1));
              [array[i], array[j]] = [array[j], array[i]];
            }
          }
          shuffleArray(playlist.videos);
          console.log(`[main] Shuffled ${playlist.videos.length} videos in playlist`);

          // add videos to orchestrator queue
          for (const v of playlist.videos) {
            await this.orchestrator.addVideo(v);
          }

          // advance into playing state (advanceQueue will trigger play-video events)
          await this.orchestrator.advanceQueue();
        }
      }
    }

    setupOrchestratorEventListeners() {
      if (!this.orchestrator) return;
      
      // wire orchestrator events to renderer so UI updates automatically
      console.log('[main] Setting up orchestrator event listeners');
      this.orchestrator.on('queue-updated', (state) => {
        console.log('[main] Sending queue:updated to renderer:', state);
        try { this.mainWindow.webContents.send('queue:updated', state); } catch (e) {}
      });
      this.orchestrator.on('play-video', (video) => {
        console.log('[main] Received play-video event, forwarding to renderer:', video.title);
        try { this.mainWindow.webContents.send('play-video', video); } catch (e) {}
      });
      console.log('[main] Orchestrator event listeners set up');
    }

    setupIPCHandlers() {
      ipcMain.on('renderer-ready', async () => {
        if (this.isShuttingDown) return;
        console.log('[main] renderer-ready received');
        // Renderer is ready, now load playlist and start playback
        await this.loadAndStartPlaylist();
      });

      ipcMain.on('playback-ended', (event, data) => {
        if (this.isShuttingDown) return;
        console.log('[main] playback-ended received', data);
        // Advance to next video
        if (this.orchestrator) {
          this.orchestrator.advanceQueue();
        }
      });

      ipcMain.on('skip-completed', (event, data) => {
        if (this.isShuttingDown) return;
        console.log('[main] skip-completed received', data);
        // Skip completed, advance to next
        if (this.orchestrator) {
          this.orchestrator.advanceQueue();
        }
      });

      // Handle invoke calls
      ipcMain.handle('get-preferences', () => {
        // Return default preferences for now
        return {
          kioskMode: false,
          showLogoOverlay: false,
          showNowPlaying: true,
          nowPlayingPosition: 'bottom',
          nowPlayingStyle: 'modern',
          nowPlayingDuration: 5
        };
      });

      ipcMain.handle('get-system-info', () => {
        return {
          version: '0.1.0',
          platform: process.platform,
          memory: process.memoryUsage()
        };
      });

      ipcMain.handle('orchestrator-command', async (event, command) => {
        if (this.isShuttingDown) {
          throw new Error('App is shutting down');
        }
        if (!this.orchestrator) {
          throw new Error('Orchestrator not initialized');
        }
        
        // Map renderer's format to orchestrator's expected format
        const orchestratorCommand = {
          action_type: command.action,
          action_data: command.data
        };
        
        await this.orchestrator.handleAdminCommand(orchestratorCommand);
        return { success: true };
      });

      // Forward renderer console logs to terminal (development only)
      ipcMain.on('renderer-log', (event, data) => {
        const { level, args } = data;
        const prefix = `[renderer:${level}]`;
        switch (level) {
          case 'log':
            console.log(prefix, ...args);
            break;
          case 'warn':
            console.warn(prefix, ...args);
            break;
          case 'error':
            console.error(prefix, ...args);
            break;
          default:
            console.log(prefix, ...args);
        }
      });

      // Handle renderer fatal errors (development only)
      ipcMain.on('renderer-fatal-error', (event, data) => {
        console.error('[FATAL] Renderer Fatal Error:');
        console.error('Error:', data.error);
        console.error('Stack:', data.stack);
        app.quit(); // Quit the app immediately
      });
    }

    async loadAndStartPlaylist() {
      if (this.isShuttingDown) {
        console.log('[main] Skipping loadAndStartPlaylist - app is shutting down');
        return;
      }
      
      console.log('[main] loadAndStartPlaylist called');
      
      // Don't recreate orchestrator if it already exists
      if (this.orchestrator) {
        console.log('[main] Orchestrator already exists, skipping recreation');
        return;
      }
      
      try {
        // Use prefs for file manager
        const prefs = await this.preferences.load();
        const playlistsRoot = prefs.djammsPath || prefs.playlistsPath || process.env.DJAMMS_PROJECT_FOLDER_PATH;
        console.log('[main] playlistsRoot:', playlistsRoot);
        const fileManager = new LocalFileManager(playlistsRoot);
        console.log('[main] LocalFileManager created');
        
        // Initialize Supabase adapter
        this.supabase = new SupabaseAdapter();
        const playerId = process.env.PLAYER_ID || 'electron-player-1';
        
        this.orchestrator = new QueueOrchestrator(this.supabase, fileManager);
        console.log('[main] QueueOrchestrator created');
        await this.orchestrator.initialize();
        console.log('[main] QueueOrchestrator initialized');

        // Initialize CommandProcessor
        this.commandProcessor = new CommandProcessor(this.orchestrator, this.supabase);
        await this.commandProcessor.initialize();
        console.log('[main] CommandProcessor initialized');

        // Send orchestrator-ready to renderer
        this.mainWindow.webContents.send('orchestrator-ready');

        // Set up orchestrator event listeners
        this.setupOrchestratorEventListeners();

        // load default playlist path from env
        const defaultPlaylistPath = process.env.DJAMMS_DEFAULT_PLAYLIST_PATH || (playlistsRoot ? `${playlistsRoot}/DJAMMS Default` : null);
        if (defaultPlaylistPath) {
          const playlist = await fileManager.getPlaylistByPath(defaultPlaylistPath);
          if (playlist && playlist.videos && playlist.videos.length > 0) {
            // Sync videos to Supabase if connected
            if (this.supabase.connected()) {
              try {
                await this.supabase.syncLocalVideos(playerId, playlist.videos);
                console.log(`[main] Synced ${playlist.videos.length} videos to Supabase`);
              } catch (syncError) {
                console.warn('[main] Failed to sync videos to Supabase:', syncError.message);
              }
            }

            // Shuffle the playlist randomly before adding to queue
            function shuffleArray(array) {
              for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
              }
            }
            shuffleArray(playlist.videos);
            console.log(`[main] Shuffled ${playlist.videos.length} videos in playlist`);

            // add videos to orchestrator queue
            for (const v of playlist.videos) {
              await this.orchestrator.addVideo(v);
            }

            // advance into playing state (advanceQueue will trigger play-video events)
            await this.orchestrator.advanceQueue();
          }
        }
      } catch (err) {
        console.warn('[main] orchestrator/setup failed', err && err.message ? err.message : err);
      }
    }

    async createPlayerWindow(prefs) {
      // Use prefs for window config
      this.mainWindow = new BrowserWindow({
        width: 1200,
        height: 800,
        fullscreen: prefs.fullscreen !== false,
        kiosk: prefs.kioskMode !== false,
        webPreferences: {
          nodeIntegration: false,
          contextIsolation: true,
          webSecurity: false,
          preload: path.join(__dirname, '..', 'renderer', 'preload.js'),
          additionalArguments: isDev ? ['--debug'] : []
        }
      });

      console.log('[main] BrowserWindow created, id:', this.mainWindow.id);

      const playerPath = '/Users/mikeclarkin/Music/DJAMMS/DJAMMS_Electron/src/renderer/player/player.html';
      console.log('[main] __dirname:', __dirname);
      console.log('[main] playerPath:', playerPath);
      console.log('[main] path exists:', require('fs').existsSync(playerPath));
      this.mainWindow.loadFile(playerPath)
        .then(() => {
          console.log('[main] player.html loaded successfully:', playerPath);
          try { log.info('[main] player.html loaded successfully:', playerPath); } catch (e) {}
          
          // Start playlist loading immediately after HTML loads
          setTimeout(() => {
            this.loadAndStartPlaylist().catch(err => {
              console.error('[main] loadAndStartPlaylist failed:', err);
            });
          }, 1000); // Give renderer time to initialize
        })
        .catch((err) => {
          console.error('[main] failed to load player.html:', err);
          // fallback to a basic page so the window is visible
          try { 
            this.mainWindow.loadURL('data:text/html,<h1>Obie Player - Error Loading</h1><p>Error: ' + err.message + '</p>');
          } catch (e) { 
            console.error('[main] fallback loadURL also failed:', e);
          }
        });

      // Set up IPC handlers
      this.setupIPCHandlers();

      // Add window event listeners for debugging
      this.mainWindow.on('ready-to-show', () => {
        console.log('[main] window ready-to-show event');
      });

      this.mainWindow.on('show', () => {
        console.log('[main] window show event');
      });

      this.mainWindow.on('hide', () => {
        console.log('[main] window hide event');
      });

      this.mainWindow.on('close', () => {
        console.log('[main] window close event');
      });

      this.mainWindow.on('closed', () => {
        console.log('[main] window closed event - setting mainWindow to null');
        this.mainWindow = null;
      });

      this.mainWindow.webContents.on('did-finish-load', () => {
        console.log('[main] webContents did-finish-load');
      });

      this.mainWindow.webContents.on('dom-ready', () => {
        console.log('[main] webContents dom-ready');
      });

      this.mainWindow.webContents.on('crashed', (event, killed) => {
        console.error('[main] webContents crashed, killed:', killed);
      });

      // Show when ready; in dev we also force the window to front and open DevTools.
      this.mainWindow.once('ready-to-show', async () => {
        console.log('[main] ready-to-show fired — window is shown');
        try { log.info('[main] ready-to-show fired — window is shown'); } catch (e) {}
        
        // Force visibility
        try {
          this.mainWindow.maximize();
          this.mainWindow.setVisibleOnAllWorkspaces(true);
          this.mainWindow.focus();
          console.log('[main] Window maximized, focused');
        } catch (e) { console.error('[main] Error forcing visibility:', e); }

        const isDevMode = process.env.NODE_ENV === 'development' || process.env.ELECTRON_ENABLE_LOGGING === 'true' || process.argv.includes('--debug');
        if (isDevMode) {
          try { this.mainWindow.webContents.openDevTools({ mode: 'right' }); } catch (e) { /* ignore */ }

          // Move the window to the primary display's bounds so it's visible and front-most
          try {
            const bounds = screen.getPrimaryDisplay().bounds;
            this.mainWindow.setBounds(bounds);
          } catch (e) { /* ignore */ }

          // Release alwaysOnTop shortly after to allow normal window interaction
          setTimeout(() => { try { this.mainWindow.setAlwaysOnTop(false); } catch (e) {} }, 3000);
        }

        setTimeout(() => { try { this.mainWindow.focus(); } catch (e) {} }, 250);

        // Orchestrator setup is now handled in renderer-ready handler
      });

      this.mainWindow.on('closed', () => { 
        this.mainWindow = null; 
        this.isShuttingDown = true;
      });
    }
  }

  module.exports = ObieElectronPlayer;

// Standard Electron main process setup
console.log('[main] Setting up Electron app handlers');
let player = null;

app.on('ready', () => {
  console.log('[main] app ready event fired');
  try {
    console.log('[main] Creating ObieElectronPlayer instance');
    player = new ObieElectronPlayer();
    console.log('[main] ObieElectronPlayer created, calling createWindow');
    player.createPlayerWindow(player.preferences.load());
    console.log('[main] createWindow completed');
  } catch (err) {
    console.error('[main] Error in app ready handler:', err);
    console.error(err.stack);
    process.exit(1);
  }
});

app.on('window-all-closed', () => {
  console.log('[main] window-all-closed');
  if (process.platform !== 'darwin') app.quit();
});

app.on('activate', () => {
  console.log('[main] app activate event fired');
  console.log('[main] player exists:', !!player);
  console.log('[main] player.mainWindow:', player?.mainWindow);
  if (player && player.mainWindow === null) {
    console.log('[main] mainWindow is null, calling createWindow');
    player.createPlayerWindow(player.preferences.load());
  } else if (player && player.mainWindow && !player.mainWindow.isDestroyed()) {
    console.log('[main] Window already exists and is not destroyed, focusing it');
    player.mainWindow.focus();
  } else {
    console.log('[main] not creating window - conditions not met');
  }
});
