console.log('[main] main.js loaded, starting ObieElectronPlayer');

try {
  const { app, BrowserWindow, screen, ipcMain } = require('electron');
  console.log('[main] electron required');
  const log = require('electron-log');
  console.log('[main] electron-log required');
  const QueueOrchestrator = require('../integration/queue-orchestrator');
  console.log('[main] QueueOrchestrator required');
  const LocalFileManager = require('../integration/local-file-manager');
  console.log('[main] LocalFileManager required');
  const path = require('path');
  console.log('[main] path required');

  class ObieElectronPlayer {
    constructor() {
      console.log('[main] constructor called');
      this.mainWindow = null;
      this.orchestrator = null;
      console.log('[main] calling init');
      this.init();
      console.log('[main] constructor finished');
    }

  setupIPCHandlers() {
    ipcMain.on('renderer-ready', async () => {
      console.log('[main] renderer-ready received');
      // Renderer is ready, now load playlist and start playback
      await this.loadAndStartPlaylist();
    });

    ipcMain.on('playback-ended', (event, data) => {
      console.log('[main] playback-ended received', data);
      // Advance to next video
      if (this.orchestrator) {
        this.orchestrator.advanceQueue();
      }
    });

    ipcMain.on('skip-completed', (event, data) => {
      console.log('[main] skip-completed received', data);
      // Skip completed, advance to next
      if (this.orchestrator) {
        this.orchestrator.advanceQueue();
      }
    });

    // Handle invoke calls
    ipcMain.handle('get-preferences', () => {
      // Return default preferences for now
      return {
        kioskMode: false,
        showLogoOverlay: false,
        showNowPlaying: true,
        nowPlayingPosition: 'bottom',
        nowPlayingStyle: 'modern',
        nowPlayingDuration: 5
      };
    });

    ipcMain.handle('get-system-info', () => {
      return {
        version: '0.1.0',
        platform: process.platform,
        memory: process.memoryUsage()
      };
    });
  }

  async loadAndStartPlaylist() {
    try {
      const playlistsRoot = process.env.DJAMMS_PLAYLISTS_FOLDER_PATH || process.env.DJAMMS_PROJECT_FOLDER_PATH || null;
      const fileManager = new LocalFileManager(playlistsRoot);
      this.orchestrator = new QueueOrchestrator(null, fileManager);
      await this.orchestrator.initialize();

      // Send orchestrator-ready to renderer
      this.mainWindow.webContents.send('orchestrator-ready');

      // wire orchestrator events to renderer so UI updates automatically
      this.orchestrator.on('queue-updated', (state) => {
        try { this.mainWindow.webContents.send('queue:updated', state); } catch (e) {}
      });
      this.orchestrator.on('play-video', (video) => {
        try { this.mainWindow.webContents.send('play-video', video); } catch (e) {}
      });

      // load default playlist path from env
      const defaultPlaylistPath = process.env.DJAMMS_DEFAULT_PLAYLIST_PATH || (playlistsRoot ? `${playlistsRoot}/DJAMMS Default` : null);
      if (defaultPlaylistPath) {
        const playlist = await fileManager.getPlaylistByPath(defaultPlaylistPath);
        if (playlist && playlist.videos && playlist.videos.length > 0) {
          // add videos to orchestrator queue
          for (const v of playlist.videos) {
            await this.orchestrator.addVideo(v);
          }

          // advance into playing state (advanceQueue will trigger play-video events)
          await this.orchestrator.advanceQueue();
        }
      }
    } catch (err) {
      console.warn('[main] orchestrator/setup failed', err && err.message ? err.message : err);
    }
  }

  init() {
    console.log('[main] init called');
    // Prefer whenReady() so we get a promise and can await initialization in the future
    app.whenReady().then(() => {
      console.log('[main] app.whenReady fired');
      this.createWindow();
    });
    app.on('window-all-closed', () => {
      console.log('[main] window-all-closed');
      if (process.platform !== 'darwin') app.quit();
    });
    app.on('activate', () => {
      console.log('[main] app activate');
      if (this.mainWindow === null) this.createWindow();
    });
  }

  createWindow() {
    console.log('[main] createWindow called');
    const isDev = process.env.NODE_ENV === 'development' || process.env.ELECTRON_ENABLE_LOGGING === 'true';

    console.log('[main] creating BrowserWindow');
    this.mainWindow = new BrowserWindow({
      width: 1200,
      height: 800,
      show: true, // show immediately
      backgroundColor: '#000000',
      center: true,
      alwaysOnTop: isDev,
      kiosk: false,
      fullscreen: false,
      fullscreenable: false,
      webPreferences: {
        nodeIntegration: false,
        contextIsolation: true,
        webSecurity: false,
        preload: path.join(__dirname, '..', '..', 'renderer', 'preload.js')
      }
    });

    console.log('[main] BrowserWindow created, id:', this.mainWindow.id);

    const playerPath = path.join(__dirname, '..', '..', 'renderer', 'player', 'player.html');
    console.log('[main] loading file:', playerPath);
    this.mainWindow.loadFile(playerPath)
      .then(() => {
        console.log('[main] player.html loaded successfully:', playerPath);
        try { log.info('[main] player.html loaded successfully:', playerPath); } catch (e) {}
      })
      .catch((err) => {
        console.error('[main] failed to load player.html', err);
        // fallback to a basic page so the window is visible
        try { this.mainWindow.loadURL('data:text/html,<h1>Obie Player</h1>'); } catch (e) { /* ignore */ }
      });

    // Set up IPC handlers
    this.setupIPCHandlers();

    // Add window event listeners for debugging
    this.mainWindow.on('ready-to-show', () => {
      console.log('[main] window ready-to-show event');
    });

    this.mainWindow.on('show', () => {
      console.log('[main] window show event');
    });

    this.mainWindow.on('hide', () => {
      console.log('[main] window hide event');
    });

    this.mainWindow.on('close', () => {
      console.log('[main] window close event');
    });

    this.mainWindow.on('closed', () => {
      console.log('[main] window closed event');
      this.mainWindow = null;
    });

    this.mainWindow.webContents.on('did-finish-load', () => {
      console.log('[main] webContents did-finish-load');
    });

    this.mainWindow.webContents.on('dom-ready', () => {
      console.log('[main] webContents dom-ready');
    });

    this.mainWindow.webContents.on('crashed', (event, killed) => {
      console.error('[main] webContents crashed, killed:', killed);
    });

    // Show when ready; in dev we also force the window to front and open DevTools.
    this.mainWindow.once('ready-to-show', async () => {
      console.log('[main] ready-to-show fired — window is shown');
      try { log.info('[main] ready-to-show fired — window is shown'); } catch (e) {}
      
      // Force visibility
      try {
        this.mainWindow.maximize();
        this.mainWindow.setVisibleOnAllWorkspaces(true);
        this.mainWindow.focus();
        console.log('[main] Window maximized, focused');
      } catch (e) { console.error('[main] Error forcing visibility:', e); }

      if (isDev) {
        try { this.mainWindow.webContents.openDevTools({ mode: 'right' }); } catch (e) { /* ignore */ }

        // Move the window to the primary display's bounds so it's visible and front-most
        try {
          const bounds = screen.getPrimaryDisplay().bounds;
          this.mainWindow.setBounds(bounds);
        } catch (e) { /* ignore */ }

        // Release alwaysOnTop shortly after to allow normal window interaction
        setTimeout(() => { try { this.mainWindow.setAlwaysOnTop(false); } catch (e) {} }, 3000);
      }

      setTimeout(() => { try { this.mainWindow.focus(); } catch (e) {} }, 250);

      // Orchestrator setup is now handled in renderer-ready handler
    });

    this.mainWindow.on('closed', () => { this.mainWindow = null; });
  }
}

module.exports = ObieElectronPlayer;

// If run directly, start the app
if (require.main === module) {
  // eslint-disable-next-line no-new
  new ObieElectronPlayer();
}
